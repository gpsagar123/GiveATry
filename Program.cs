using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

/// <summary>
/// Project Description
//Problem Statement
//Let's race!
//Consider N(> 3) race drivers trying to win the grand prix.These drivers are fierce rivals.
//Each driver can be in one among 3 states of mind depending on the position of the driver in the race.
//For simplicity, let’s assume that during the race the drivers can be in one of the following positions.
//NEW.This list has been updated.
//1. LEADING: Driver.Position<( 0.3 * Total Number of Drivers )
//2. HOLDING_ON: RoundToClosestInt( 0.3 * Total Number of Drivers) ≤ Driver.Position<RoundToClosestInt( 0.7 * Total Number of Drivers )
//3. LOSING: Driver.Position ≥ RoundToClosestInt( 0.7 * Total Number of Drivers)
//Depending on the position of the driver in the race, he/she is in a different state of mind.These states are defined below.
//1. If a driver is LEADING, then the driver is in a CONFIDENT state of mind.
//2. If a driver is LOSING, then the driver is in RECKLESS state of mind.
//3. If a driver is HOLDING_ON, then the driver is in a CALCULATIVE state of mind.
//Note: Remember the drivers are fierce rivals. Hence, if two or more drivers are sharing position, then they are going to be RECKLESS.
//Input
//Input will be given in the form of a file.The number of drivers would be specified in the first line of the file. Each subsequent line in the input file would specify
//the distance covered by each driver in each minute. The ith
// distance corresponds to the ith
// driver. The format of the input file is shown below.
//N
//<Distances covered by all N drivers each minute>
//0
//th
// 1st
// 2nd
// ... Nth
//0
//th
// 1st
// 2nd
// ... Nth
//0
//th
// 1st
// 2nd
// ... Nth
//...
//Note: The input file will be well formatted and will not contain any extra spaces between distances. Also, The line 'Distances covered by all N drivers each
//minute' will not actually be there in the input file and was added just to explain the contents.
//Output
//An output file should be generated by the program by the name listed in the command line.For example, you may get the name of the output file as output.txt.
//For each line after the first, the program should write the state of mind for each driver in the race. For each line after the first to N, the program should write the
//state of mind for each driver in the race.
//Sample Input/Output
//Sample input is as shown below. The input will be doubles with a maximum of 1 digit of precision.Use Java API to parse a Double out of a String, and then
//extract the double value.
//4
//1 2 3 4
//4 3 2 1
//1 1.5 0.5 2
//Sample output is as shown below. NEW: This section has been updated.
//RECKLESS RECKLESS CALCULATIVE CONFIDENT
//RECKLESS RECKLESS RECKLESS RECKLESS
//RECKLESS CALCULATIVE RECKLESS CONFIDENT
///// </summary>

namespace LetsRace
{

    public class Program
    {

        public static void Main(string[] args)
        {
            int number_Of_Drivers = 0;

            Console.WriteLine("Welcome to Lets Race Compition \n Based on driver Position we display the state of the driver !!");

            string[] lines = File.ReadAllLines(@"C:\Users\z003s7ry\Desktop\input1.txt");

            Console.WriteLine("File Contents : ");

            foreach (var str in lines)
            {
                Console.WriteLine(str);
            }

            //First line read the number of drivers
            if (lines.Length > 0)
            {
                //Console.WriteLine("driver" + lines[0]);
                number_Of_Drivers = int.Parse(lines[0]);
            }

            Dictionary<int, float[]> laps_distance = new Dictionary<int, float[]>();
            for (int i = 1; i <= lines.Length - 1; i++)
            {
                laps_distance.Add(i, (Array.ConvertAll<string, float>(lines[i].Split(' '), float.Parse)));
            }


            //Dictionary<int, float[]> laps_totalDistance = new Dictionary<int, float[]>();
            for (int i = 1; i <= laps_distance.Count; i++)
            {
                if (i == 1)
                    PrintStatus(i, laps_distance[i]);

                //To calculate total distance after every lap
                if (i > 1)
                {
                    float[] previousValue = laps_distance[i - 1];
                    float[] value = laps_distance[i];

                    for (int j = 0; j < value.Length; j++)
                    {
                        value[j] = value[j] + previousValue[j];
                    }
                    PrintStatus(i, value);
                }
            }

            Console.ReadLine();
        }


        private static void PrintStatus(int lap_Number, float[] distance)
        {
            var temp = distance;
            Console.WriteLine("Lap Number : " + lap_Number);

            int[] rider_position1 = new int[distance.Length + 1];

            distance = distance.OrderByDescending(a => a).ToArray();

            for (int i = 0; i < distance.Length; i++)
            {
                for (int j = 0; j < distance.Length; j++)
                {
                    if (temp[i] == distance[j])
                        // rider_Position.Add(i + 1 , j + 1); //i is the rider j is the position based on distace covered
                        rider_position1[i + 1] = j + 1;
                }
            }

            DispayStateOfMind(rider_position1);

            //TODO Based on the driver position display the state of mind
        }

        private static void DispayStateOfMind(int[] rider_position1)
        {
            int total_number_Of_drivers = rider_position1.Length - 1;
            Dictionary<int, string> finalResult = new Dictionary<int, string>();

            for (int i = 1; i < rider_position1.Length; i++)
            {
                for (int j = 1; j < rider_position1.Length; j++)
                {
                    if (rider_position1[i] == rider_position1[j] && i != j)
                    {
                        if (finalResult.ContainsKey(i))
                        {
                            finalResult.Remove(i);
                            finalResult.Add(i, "RECKLESS");
                            //finalResult.Add(j, "RECKLESS");
                        }
                        else
                        {
                            finalResult.Add(i, "RECKLESS");
                            //finalResult.Add(j, "RECKLESS");
                        }
                        break;
                    }
                }
                if (!finalResult.ContainsKey(i))
                {
                    //LEADING: Driver.Position < (0.3 * Total Number of Drivers )
                    //2.HOLDING_ON: RoundToClosestInt(0.3 * Total Number of Drivers) ≤ Driver.Position < RoundToClosestInt(0.7 * Total Number of Drivers)
                    //3.LOSING: Driver.Position ≥ RoundToClosestInt(0.7 * Total Number of Drivers)

                    if (rider_position1[i] < (0.3 * total_number_Of_drivers))
                    {
                        finalResult.Add(i, "CONFIDENT");
                    }
                    else if (((0.3 * total_number_Of_drivers) <= rider_position1[i]) && (rider_position1[i] < (0.7 * total_number_Of_drivers)))
                    {
                        finalResult.Add(i, "CALCULATIVE");
                    }
                    else if (rider_position1[i] >= (0.7 * total_number_Of_drivers))
                    {
                        finalResult.Add(i, "RECKLESS");
                    }

                }

            }

            foreach (var str in finalResult)
            {
                Console.Write(str.Value + " ");
            }
            Console.WriteLine("\n");

        }


    }
}
